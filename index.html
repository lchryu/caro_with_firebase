<!DOCTYPE html>
<html>
  <head>
    <title>Gomoku Online</title>
    <link rel="stylesheet" href="main.css" />
  </head>
  <body>
    <!-- Login Screen -->
    <div id="loginScreen" class="screen-container">
      <div class="login-box">
        <h1>Gomoku Online</h1>
        <div id="beforeLogin">
          <button id="loginBtn" class="btn-google">
            <img
              src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg"
              width="18"
              height="18"
            />
            Sign in with Google
          </button>
        </div>

        <div id="afterLogin" class="hidden">
          <div class="user-info">
            <img id="userAvatar" class="user-avatar" src="" alt="Your avatar" />
            <span id="userName"></span>
          </div>

          <div class="join-create-section">
            <button id="createRoomBtn" class="btn btn-primary">
              Create New Room
            </button>

            <div class="join-section">
              <h3>Or Join Room</h3>
              <div class="join-input-group">
                <input
                  type="text"
                  id="roomIdInput"
                  placeholder="Enter Room ID"
                  class="room-input"
                  maxlength="6"
                />
                <button id="joinRoomBtn" class="btn btn-secondary">
                  Join Room
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Room Screen -->
    <div id="roomScreen" class="screen-container hidden">
      <div class="room-container">
        <div class="room-info">
          <div class="room-header">
            <h2>Game Room</h2>
            <div class="room-id">Room ID: <span id="roomIdDisplay"></span></div>
          </div>

          <div class="players-container">
            <div class="player-card">
              <img
                id="player1Avatar"
                class="user-avatar"
                src=""
                alt="Player 1"
              />
              <div class="player-info">
                <div id="player1Name"></div>
              </div>
              <div id="player1Status" class="player-status status-waiting">
                Waiting
              </div>
            </div>

            <div class="player-card">
              <img
                id="player2Avatar"
                class="user-avatar"
                src=""
                alt="Player 2"
              />
              <div class="player-info">
                <div id="player2Name">Waiting for player...</div>
              </div>
              <div id="player2Status" class="player-status status-waiting">
                Waiting
              </div>
              <button id="kickPlayer" class="btn btn-secondary kick-btn hidden">
                Kick
              </button>
            </div>
          </div>

          <div class="room-controls">
            <button id="readyBtn" class="btn btn-primary">Ready</button>
            <button id="leaveRoomBtn" class="btn btn-secondary">
              Leave Room
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="screen-container hidden">
      <div class="game-container">
        <div class="game-info">
          <h2>Game Info</h2>
          <div class="player-info">
            <div class="active-players">
              <div class="player-symbol">
                You: <span id="playerSymbol"></span>
              </div>
            </div>
          </div>
          <div class="turn-info">
            <div id="turnIndicator">Waiting for game to start...</div>
            <div class="timer">Time: <span id="timeDisplay">60</span>s</div>
          </div>
          <div class="game-controls">
            <button id="surrenderBtn" class="btn btn-secondary">
              Surrender
            </button>
          </div>
        </div>

        <div class="game-board-container">
          <div id="gameBoard" class="game-board"></div>
        </div>
      </div>
    </div>

    <!-- Chat Container -->
    <div id="chatContainer" class="chat-container">
      <div class="chat-header">
        <h3>Chat Room</h3>
        <button class="chat-toggle" id="chatToggle">−</button>
      </div>
      <div class="chat-content">
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-input-container">
          <input
            type="text"
            class="chat-input"
            id="chatInput"
            placeholder="Type a message..."
          />
          <button class="chat-send" id="chatSend">Send</button>
        </div>
      </div>
    </div>

    <!-- Additional Styles -->
    <style>
      /* Chat styles */
      .chat-container {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 300px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        backdrop-filter: blur(4px);
        z-index: 1000;
      }

      .chat-header {
        padding: 15px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .chat-toggle {
        background: none;
        border: none;
        color: #5ee7ff;
        cursor: pointer;
        font-size: 20px;
        padding: 0;
      }

      .chat-messages {
        height: 300px;
        overflow-y: auto;
        padding: 15px;
      }

      .chat-message {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 10px;
      }

      .chat-message.player1 .message-sender {
        color: #5ee7ff;
      }

      .chat-message.player2 .message-sender {
        color: #ff5e5e;
      }

      .chat-input-container {
        padding: 15px;
        display: flex;
        gap: 10px;
      }

      .chat-input {
        flex-grow: 1;
        padding: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.05);
        color: white;
      }

      .chat-send {
        padding: 8px 15px;
        background: #5ee7ff;
        color: #1a1b1e;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }

      /* Game Info Additional Styles */
      .player-info {
        margin-bottom: 20px;
      }

      .active-players {
        background: rgba(255, 255, 255, 0.05);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 10px;
      }

      .player-symbol {
        font-size: 1.1em;
        color: #5ee7ff;
      }

      /* Timer styles */
      .timer {
        font-size: 1.2em;
        font-weight: bold;
        color: #5ee7ff;
        text-align: center;
        margin: 10px 0;
      }

      /* Countdown Overlay */
      .countdown-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
      }

      .countdown-number {
        font-size: 120px;
        color: #5ee7ff;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      /* Enhanced Game Board Styles */
      .game-board-container {
        position: relative;
        padding: 20px;
      }

      .game-board {
        box-shadow: 0 0 20px rgba(94, 231, 255, 0.1);
      }

      .cell {
        transition: background-color 0.2s;
      }

      .cell:hover:not(.player1):not(.player2) {
        background: rgba(94, 231, 255, 0.1);
      }

      .cell.valid-first-move {
        animation: pulse-subtle 2s infinite;
      }

      @keyframes pulse-subtle {
        0% {
          background: rgba(94, 231, 255, 0.1);
        }
        50% {
          background: rgba(94, 231, 255, 0.2);
        }
        100% {
          background: rgba(94, 231, 255, 0.1);
        }
      }
    </style>
    <script type="module">
      // Firebase Imports
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import {
        getAuth,
        signInWithPopup,
        GoogleAuthProvider,
        onAuthStateChanged,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
      import {
        getFirestore,
        doc,
        setDoc,
        getDoc,
        onSnapshot,
        updateDoc,
        arrayUnion,
        deleteDoc,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

      // Firebase Configuration
      const firebaseConfig = {
        apiKey: "AIzaSyDynAI_d34bY2J2TpiXi-cFJu-yQjBXWwU",
        authDomain: "caro-firebase.firebaseapp.com",
        projectId: "caro-firebase",
        storageBucket: "caro-firebase.firebasestorage.app",
        messagingSenderId: "357402393311",
        appId: "1:357402393311:web:5185772e05c641c5ef876a",
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const auth = getAuth();
      const db = getFirestore();
      const provider = new GoogleAuthProvider();

      // Game Constants
      const BOARD_SIZE = { ROWS: 17, COLS: 19 };
      const TIMER_DURATION = 60;
      const CENTER = {
        ROW: Math.floor(BOARD_SIZE.ROWS / 2),
        COL: Math.floor(BOARD_SIZE.COLS / 2),
      };

      // Game State
      let gameState = {
        user: null,
        roomId: null,
        isHost: false,
        isReady: false,
        board: Array(BOARD_SIZE.ROWS * BOARD_SIZE.COLS).fill(""),
        currentPlayer: "1",
        timeRemaining: TIMER_DURATION,
        timerInterval: null,
        playerSymbol: null,
        gameStatus: "waiting",
        moveCount: 0,
        unsubscribe: null,
        lastMove: null,
      };

      // Chat State
      let chatVisible = true;

      // DOM Elements
      const screens = {
        login: document.getElementById("loginScreen"),
        room: document.getElementById("roomScreen"),
        game: document.getElementById("gameScreen"),
      };

      // Login Elements
      const loginBtn = document.getElementById("loginBtn");
      const createRoomBtn = document.getElementById("createRoomBtn");
      const joinRoomBtn = document.getElementById("joinRoomBtn");
      const roomIdInput = document.getElementById("roomIdInput");

      // Room Elements
      const readyBtn = document.getElementById("readyBtn");
      const leaveRoomBtn = document.getElementById("leaveRoomBtn");
      const roomIdDisplay = document.getElementById("roomIdDisplay");
      const playerSymbolDisplay = document.getElementById("playerSymbol");

      // Game Elements
      const gameBoard = document.getElementById("gameBoard");
      const turnIndicator = document.getElementById("turnIndicator");
      const timeDisplay = document.getElementById("timeDisplay");
      const surrenderBtn = document.getElementById("surrenderBtn");

      // Chat Elements
      const chatToggle = document.getElementById("chatToggle");
      const chatContent = document.querySelector(".chat-content");
      const chatInput = document.getElementById("chatInput");
      const chatSend = document.getElementById("chatSend");

      // Authentication Functions
      async function handleLogin() {
        try {
          const result = await signInWithPopup(auth, provider);
          gameState.user = {
            uid: result.user.uid,
            name: result.user.displayName,
            avatar: result.user.photoURL,
          };
        } catch (error) {
          console.error("Login error:", error);
          if (error.code === "auth/popup-blocked") {
            alert("Please enable popups for this site to login");
          }
        }
      }

      // Auth State Observer
      onAuthStateChanged(auth, (user) => {
        const beforeLogin = document.getElementById("beforeLogin");
        const afterLogin = document.getElementById("afterLogin");

        if (user) {
          gameState.user = {
            uid: user.uid,
            name: user.displayName,
            avatar: user.photoURL,
          };

          document.getElementById("userAvatar").src = user.photoURL;
          document.getElementById("userName").textContent = user.displayName;

          beforeLogin.classList.add("hidden");
          afterLogin.classList.remove("hidden");
        } else {
          beforeLogin.classList.remove("hidden");
          afterLogin.classList.add("hidden");
          showScreen("login");
        }
      });

      // Screen Management
      function showScreen(screenName) {
        Object.keys(screens).forEach((key) => {
          screens[key].classList.add("hidden");
        });
        screens[screenName].classList.remove("hidden");
      }

      // Game Board Initialization
      function initializeBoard() {
        gameBoard.innerHTML = ""; // Clear current board
        for (let row = 0; row < BOARD_SIZE.ROWS; row++) {
          for (let col = 0; col < BOARD_SIZE.COLS; col++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.row = row;
            cell.dataset.col = col;

            const index = row * BOARD_SIZE.COLS + col;
            if (gameState.board[index] === "1") {
              cell.classList.add("player1");
            } else if (gameState.board[index] === "2") {
              cell.classList.add("player2");
            }

            if (row === CENTER.ROW && col === CENTER.COL) {
              cell.classList.add("center");
            }

            cell.addEventListener("click", handleCellClick);
            gameBoard.appendChild(cell);
          }
        }

        // Update symbol display
        playerSymbolDisplay.textContent =
          gameState.playerSymbol === "1" ? "X" : "O";
      }

      // Helper Functions
      function generateRoomId(length = 6) {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let result = "";
        for (let i = 0; i < length; i++) {
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }

      function isValidPosition(row, col) {
        return (
          row >= 0 && row < BOARD_SIZE.ROWS && col >= 0 && col < BOARD_SIZE.COLS
        );
      }

      function isValidFirstMove(row, col) {
        const validMoves = [
          { row: CENTER.ROW - 1, col: CENTER.COL - 1 },
          { row: CENTER.ROW - 1, col: CENTER.COL },
          { row: CENTER.ROW - 1, col: CENTER.COL + 1 },
          { row: CENTER.ROW, col: CENTER.COL - 1 },
          { row: CENTER.ROW, col: CENTER.COL + 1 },
          { row: CENTER.ROW + 1, col: CENTER.COL - 1 },
          { row: CENTER.ROW + 1, col: CENTER.COL },
          { row: CENTER.ROW + 1, col: CENTER.COL + 1 },
        ];

        return validMoves.some((move) => move.row === row && move.col === col);
      }

      // Event Listeners
      loginBtn.addEventListener("click", handleLogin);
      roomIdInput.addEventListener("input", (e) => {
        e.target.value = e.target.value.toUpperCase();
      });

      // Initialize Chat System
      function initializeChat() {
        chatToggle.addEventListener("click", () => {
          chatVisible = !chatVisible;
          chatToggle.textContent = chatVisible ? "−" : "+";
          chatContent.style.display = chatVisible ? "block" : "none";
        });

        chatSend.addEventListener("click", sendMessage);
        chatInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            sendMessage();
          }
        });
      }

      // Initialize
      initializeChat();

      // Room Management Functions
      async function createRoom() {
        try {
          const roomId = generateRoomId();
          gameState.roomId = roomId;
          gameState.isHost = true;
          gameState.playerSymbol = "1";

          const initialRoomData = {
            status: "waiting",
            player1: gameState.user,
            player1Ready: false,
            player2: null,
            player2Ready: false,
            board: gameState.board,
            currentPlayer: "1",
            messages: [],
            timeRemaining: TIMER_DURATION,
            moveCount: 0,
            createdAt: Date.now(),
            lastMove: null,
          };

          await setDoc(doc(db, "rooms", roomId), initialRoomData);
          startListeningToRoom(roomId);
          showScreen("room");
        } catch (error) {
          console.error("Error creating room:", error);
          alert("Failed to create room. Please try again.");
        }
      }

      async function joinRoom(roomId) {
        try {
          const roomRef = doc(db, "rooms", roomId);
          const roomDoc = await getDoc(roomRef);

          if (!roomDoc.exists()) {
            alert("Room not found");
            return;
          }

          const roomData = roomDoc.data();
          if (roomData.player2) {
            alert("Room is full");
            return;
          }

          gameState.roomId = roomId;
          gameState.isHost = false;
          gameState.playerSymbol = "2";

          await updateDoc(roomRef, {
            player2: gameState.user,
            player2Ready: false,
          });

          startListeningToRoom(roomId);
          showScreen("room");
        } catch (error) {
          console.error("Error joining room:", error);
          alert("Failed to join room. Please try again.");
        }
      }
      // Thêm logic xử lý chuyển host và kick
      async function handleHostLeave() {
        const roomRef = doc(db, "rooms", gameState.roomId);
        const roomDoc = await getDoc(roomRef);
        const roomData = roomDoc.data();

        if (roomData.player2) {
          // Chuyển player2 thành host
          await updateDoc(roomRef, {
            player1: roomData.player2,
            player2: null,
            player1Ready: false,
            player2Ready: false,
            status: "waiting",
          });
        } else {
          // Nếu không có player2 thì xóa room
          await deleteDoc(roomRef);
        }
      }
      // Sửa lại hàm leaveRoom
      async function leaveRoom() {
        try {
          if (!gameState.roomId) return;

          if (gameState.isReady) {
            alert("Please cancel ready before leaving room");
            return;
          }

          const roomRef = doc(db, "rooms", gameState.roomId);
          const roomId = gameState.roomId;

          if (gameState.isHost) {
            await handleHostLeave();
          } else {
            await updateDoc(roomRef, {
              player2: null,
              player2Ready: false,
              status: "waiting",
            });
          }

          resetGameState();
          showScreen("login");
        } catch (error) {
          console.error("Error leaving room:", error);
        }
      }

      // Thêm chức năng kick player
      async function kickPlayer() {
        if (!gameState.isHost) return;

        try {
          const roomRef = doc(db, "rooms", gameState.roomId);
          await updateDoc(roomRef, {
            player2: null,
            player2Ready: false,
            status: "waiting",
          });
        } catch (error) {
          console.error("Error kicking player:", error);
        }
      }

      // Real-time Room Updates
      function startListeningToRoom(roomId) {
        if (gameState.unsubscribe) {
          gameState.unsubscribe();
        }

        const unsubscribe = onSnapshot(
          doc(db, "rooms", roomId),
          async (snapshot) => {
            if (!snapshot.exists()) {
              alert("Room was closed");
              resetGameState();
              showScreen("login");
              return;
            }

            const roomData = snapshot.data();

            // Update chat messages first
            if (roomData.messages) {
              updateChatMessages(roomData.messages);
            }

            updateGameState(roomData);
            updateUI(roomData);

            // Handle game states
            switch (roomData.status) {
              case "waiting":
                if (roomData.player1Ready && roomData.player2Ready) {
                  if (gameState.isHost) {
                    startGameWithCountdown();
                  }
                }
                break;

              case "countdown":
                handleCountdown(roomData);
                break;

              case "playing":
                // Chỉ khởi tạo board nếu nó chưa được tạo
                if (gameBoard.children.length === 0) {
                  initializeBoard();
                } else {
                  updateGameBoard();
                }
                if (gameState.currentPlayer === gameState.playerSymbol) {
                  startTimer();
                }
                break;

              case "finished":
                handleGameOver(roomData);
                break;
            }
          }
        );

        gameState.unsubscribe = unsubscribe;
      }

      // Game State Management
      function updateGameState(roomData) {
        gameState.board = roomData.board;
        gameState.currentPlayer = roomData.currentPlayer;
        gameState.gameStatus = roomData.status;
        gameState.moveCount = roomData.moveCount || 0;
        gameState.timeRemaining = roomData.timeRemaining;
        gameState.lastMove = roomData.lastMove;

        if (gameState.isHost) {
          gameState.isReady = roomData.player1Ready;
        } else {
          gameState.isReady = roomData.player2Ready;
        }
      }

      function updateUI(roomData) {
        // Update room info
        roomIdDisplay.textContent = gameState.roomId;

        // Update player info
        if (roomData.player1) {
          document.getElementById("player1Name").textContent =
            roomData.player1.name;
          document.getElementById("player1Avatar").src =
            roomData.player1.avatar;
          document.getElementById("player1Status").textContent =
            roomData.player1Ready ? "Ready" : "Not Ready";
          document.getElementById("player1Status").className = `player-status ${
            roomData.player1Ready ? "status-ready" : "status-waiting"
          }`;
        }

        if (roomData.player2) {
          document.getElementById("player2Name").textContent =
            roomData.player2.name;
          document.getElementById("player2Avatar").src =
            roomData.player2.avatar;
          document.getElementById("player2Status").textContent =
            roomData.player2Ready ? "Ready" : "Not Ready";
          document.getElementById("player2Status").className = `player-status ${
            roomData.player2Ready ? "status-ready" : "status-waiting"
          }`;
        } else {
          document.getElementById("player2Name").textContent =
            "Waiting for player...";
          document.getElementById("player2Avatar").src = "";
          document.getElementById("player2Status").textContent = "Waiting";
          document.getElementById("player2Status").className =
            "player-status status-waiting";
        }

        // Update game board
        updateGameBoard();

        // Update turn indicator and timer
        if (gameState.gameStatus === "playing") {
          turnIndicator.textContent =
            gameState.currentPlayer === gameState.playerSymbol
              ? "Your turn"
              : "Opponent's turn";
          timeDisplay.textContent = gameState.timeRemaining;
        }

        // Hiện/ẩn nút kick
        const kickBtn = document.getElementById("kickPlayer");
        if (kickBtn) {
          kickBtn.classList.toggle(
            "hidden",
            !gameState.isHost || !roomData.player2
          );
        }
      }
      // Thêm event listener cho nút kick
      document
        .getElementById("kickPlayer")
        ?.addEventListener("click", kickPlayer);

        
      function updateGameBoard() {
        const cells = document.querySelectorAll(".cell");
        cells.forEach((cell, index) => {
          // Reset classes
          cell.className = "cell";

          const row = Math.floor(index / BOARD_SIZE.COLS);
          const col = index % BOARD_SIZE.COLS;

          // Add player markers
          if (gameState.board[index] === "1") {
            cell.classList.add("player1");
          } else if (gameState.board[index] === "2") {
            cell.classList.add("player2");
          }

          // Add center cell
          if (row === CENTER.ROW && col === CENTER.COL) {
            cell.classList.add("center");
          }

          // Highlight valid first moves
          if (
            gameState.moveCount === 0 &&
            gameState.gameStatus === "playing" &&
            gameState.currentPlayer === gameState.playerSymbol &&
            isValidFirstMove(row, col)
          ) {
            cell.classList.add("valid-first-move");
          }

          // Highlight last move
          if (
            gameState.lastMove &&
            row === gameState.lastMove.row &&
            col === gameState.lastMove.col
          ) {
            cell.classList.add("last-move");
          }
        });
      }

      // Game Timer Functions
      function startTimer() {
        stopTimer();
        gameState.timeRemaining = TIMER_DURATION;

        gameState.timerInterval = setInterval(async () => {
          if (gameState.timeRemaining > 0) {
            gameState.timeRemaining--;
            timeDisplay.textContent = gameState.timeRemaining;

            if (gameState.timeRemaining === 0) {
              await handleTimeout();
            }
          }
        }, 1000);
      }

      function stopTimer() {
        if (gameState.timerInterval) {
          clearInterval(gameState.timerInterval);
          gameState.timerInterval = null;
        }
      }

      async function handleTimeout() {
        try {
          await updateDoc(doc(db, "rooms", gameState.roomId), {
            status: "finished",
            winner: gameState.playerSymbol === "1" ? "2" : "1",
            timeoutPlayer: gameState.playerSymbol,
          });
        } catch (error) {
          console.error("Error handling timeout:", error);
        }
      }
      // Game Mechanics - Cell Click Handler
      async function handleCellClick(event) {
        if (
          gameState.gameStatus !== "playing" ||
          gameState.currentPlayer !== gameState.playerSymbol
        ) {
          return;
        }

        const cell = event.target;
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        const index = row * BOARD_SIZE.COLS + col;

        // Check if cell is already occupied
        if (gameState.board[index]) return;

        // Validate first move
        if (gameState.moveCount === 0 && !isValidFirstMove(row, col)) {
          alert("First move must be adjacent to the center");
          return;
        }

        try {
          const newBoard = [...gameState.board];
          newBoard[index] = gameState.playerSymbol;

          const hasWon = checkWinner(newBoard, row, col);

          await updateDoc(doc(db, "rooms", gameState.roomId), {
            board: newBoard,
            currentPlayer: gameState.playerSymbol === "1" ? "2" : "1",
            status: hasWon ? "finished" : "playing",
            lastMove: { row, col },
            timeRemaining: TIMER_DURATION,
            moveCount: gameState.moveCount + 1,
            winner: hasWon ? gameState.playerSymbol : null,
          });

          if (hasWon) {
            stopTimer();
          }
        } catch (error) {
          console.error("Error making move:", error);
          alert("Failed to make move. Please try again.");
        }
      }

      // Win Condition Checking
      function checkWinner(board, lastRow, lastCol) {
        const directions = [
          [1, 0], // vertical
          [0, 1], // horizontal
          [1, 1], // diagonal
          [1, -1], // anti-diagonal
        ];

        const symbol = board[lastRow * BOARD_SIZE.COLS + lastCol];

        for (const [dx, dy] of directions) {
          let count = 1;

          // Check forward direction
          for (let i = 1; i < 5; i++) {
            const newRow = lastRow + dx * i;
            const newCol = lastCol + dy * i;
            if (!isValidPosition(newRow, newCol)) break;
            if (board[newRow * BOARD_SIZE.COLS + newCol] !== symbol) break;
            count++;
          }

          // Check backward direction
          for (let i = 1; i < 5; i++) {
            const newRow = lastRow - dx * i;
            const newCol = lastCol - dy * i;
            if (!isValidPosition(newRow, newCol)) break;
            if (board[newRow * BOARD_SIZE.COLS + newCol] !== symbol) break;
            count++;
          }

          if (count >= 5) return true;
        }

        return false;
      }

      // Chat System
      async function sendMessage() {
        const message = chatInput.value.trim();
        if (!message || !gameState.roomId) return;

        try {
          const messageObj = {
            sender: gameState.user.name,
            content: message,
            timestamp: Date.now(),
            isPlayer1: gameState.isHost,
          };

          await updateDoc(doc(db, "rooms", gameState.roomId), {
            messages: arrayUnion(messageObj),
          });

          chatInput.value = "";
        } catch (error) {
          console.error("Error sending message:", error);
        }
      }

      function updateChatMessages(messages) {
        if (!Array.isArray(messages)) {
          console.warn("Messages is not an array:", messages);
          messages = [];
        }

        const chatMessages = document.getElementById("chatMessages");
        chatMessages.innerHTML = "";

        messages.forEach((msg) => {
          const div = document.createElement("div");
          div.className = `chat-message ${
            msg.isPlayer1 ? "player1" : "player2"
          }`;
          div.innerHTML = `
          <div class="message-sender">${msg.sender}</div>
          <div class="message-content">${msg.content}</div>
      `;
          chatMessages.appendChild(div);
        });

        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      // Countdown System
      async function startGameWithCountdown() {
        try {
          if (gameState.isHost) {
            await updateDoc(doc(db, "rooms", gameState.roomId), {
              status: "countdown",
              countdownStartTime: Date.now(),
            });
          }
        } catch (error) {
          console.error("Error starting countdown:", error);
        }
      }

      async function handleCountdown(roomData) {
        const overlay = document.createElement("div");
        overlay.className = "countdown-overlay";
        document.body.appendChild(overlay);

        let countdown = 3;

        const countdownInterval = setInterval(async () => {
          if (countdown > 0) {
            overlay.innerHTML = `<div class="countdown-number">${countdown}</div>`;
            countdown--;
          } else {
            clearInterval(countdownInterval);
            overlay.remove();
            showScreen("game");
            initializeBoard();

            if (gameState.isHost) {
              await updateDoc(doc(db, "rooms", gameState.roomId), {
                status: "playing",
                timeRemaining: TIMER_DURATION,
              });
            }
          }
        }, 1000);
      }

      // Game Over Handler
    //   function handleGameOver(roomData) {
    //     stopTimer();
    //     const winner = roomData.winner;
    //     const isWinner = winner === gameState.playerSymbol;
    //     const isTimeout = roomData.timeoutPlayer;

    //     setTimeout(() => {
    //       let message;
    //       if (isTimeout) {
    //         message =
    //           roomData.timeoutPlayer === gameState.playerSymbol
    //             ? "You lost by timeout!"
    //             : "You won! (Opponent timeout)";
    //       } else {
    //         message = isWinner
    //           ? "Congratulations! You won!"
    //           : "Game Over. You lost!";
    //       }

    //       alert(message);

    //       if (gameState.isHost) {
    //         updateDoc(doc(db, "rooms", gameState.roomId), {
    //           status: "waiting",
    //           board: Array(BOARD_SIZE.ROWS * BOARD_SIZE.COLS).fill(""),
    //           currentPlayer: "1",
    //           player1Ready: false,
    //           player2Ready: false,
    //           moveCount: 0,
    //           winner: null,
    //           timeoutPlayer: null,
    //           lastMove: null,
    //         });
    //       }
    //     }, 500);
    //   }
      // Game Over Handler
function handleGameOver(roomData) {
  stopTimer();
  const winner = roomData.winner;
  const isWinner = winner === gameState.playerSymbol;
  const isTimeout = roomData.timeoutPlayer;

  setTimeout(() => {
    let message;
    if (isTimeout) {
      message = roomData.timeoutPlayer === gameState.playerSymbol
        ? "You lost by timeout!"
        : "You won! (Opponent timeout)";
    } else {
      message = isWinner ? "Congratulations! You won!" : "Game Over. You lost!";
    }

    alert(message);

    // Reset game state and return to room screen
    if (gameState.isHost) {
      updateDoc(doc(db, "rooms", gameState.roomId), {
        status: "waiting",
        board: Array(BOARD_SIZE.ROWS * BOARD_SIZE.COLS).fill(""),
        currentPlayer: "1",
        player1Ready: false,
        player2Ready: false,
        moveCount: 0,
        winner: null,
        timeoutPlayer: null,
        lastMove: null,
      });
    }

    // Return both players to room screen
    showScreen("room");
    
    // Reset ready button state
    const readyBtn = document.getElementById("readyBtn");
    readyBtn.textContent = "Ready";
    gameState.isReady = false;

    // Reset game board
    const gameBoard = document.getElementById("gameBoard");
    gameBoard.innerHTML = "";

  }, 500);
}
      // Additional Event Listeners
      surrenderBtn.addEventListener("click", async () => {
        try {
          await updateDoc(doc(db, "rooms", gameState.roomId), {
            status: "finished",
            winner: gameState.playerSymbol === "1" ? "2" : "1",
          });
        } catch (error) {
          console.error("Error surrendering:", error);
        }
      });

      createRoomBtn.addEventListener("click", createRoom);
      joinRoomBtn.addEventListener("click", () => {
        const roomId = roomIdInput.value.trim().toUpperCase();
        if (roomId) {
          joinRoom(roomId);
        } else {
          alert("Please enter a room ID");
        }
      });

      readyBtn.addEventListener("click", async () => {
        try {
          const readyField = gameState.isHost ? "player1Ready" : "player2Ready";
          gameState.isReady = !gameState.isReady;

          await updateDoc(doc(db, "rooms", gameState.roomId), {
            [readyField]: gameState.isReady,
          });

          readyBtn.textContent = gameState.isReady ? "Cancel Ready" : "Ready";
        } catch (error) {
          console.error("Error updating ready state:", error);
        }
      });
      function resetGameState() {
        // Dừng timer nếu đang chạy
        stopTimer();

        // Dừng lắng nghe thay đổi từ room
        if (gameState.unsubscribe) {
          gameState.unsubscribe();
        }

        // Lưu lại thông tin user hiện tại
        const currentUser = gameState.user;

        // Reset toàn bộ state về mặc định
        gameState = {
          user: currentUser, // Giữ lại thông tin user
          roomId: null,
          isHost: false,
          isReady: false,
          board: Array(BOARD_SIZE.ROWS * BOARD_SIZE.COLS).fill(""),
          currentPlayer: "1",
          timeRemaining: TIMER_DURATION,
          timerInterval: null,
          playerSymbol: null,
          gameStatus: "waiting",
          moveCount: 0,
          unsubscribe: null,
          lastMove: null,
        };

        // Clear game board
        const gameBoard = document.getElementById("gameBoard");
        if (gameBoard) {
          gameBoard.innerHTML = "";
        }

        // Reset UI elements
        const readyBtn = document.getElementById("readyBtn");
        if (readyBtn) {
          readyBtn.textContent = "Ready";
        }
      }
      leaveRoomBtn.addEventListener("click", leaveRoom);

      // Cleanup function for page unload
      window.addEventListener("beforeunload", () => {
        if (gameState.roomId) {
          leaveRoom();
        }
        if (gameState.unsubscribe) {
          gameState.unsubscribe();
        }
      });
    </script>
  </body>
</html>
